---
title: "Cryptorgraphy is more fun with R - Learn and use Public Key Cryptography with R Statistical Software"
output:
  html_document: default
  html_notebook: default
  pdf_document: default
  word_document: default
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

https://www.udemy.com/keep-your-secrets-under-control

#### Disclamer

By joining this course or using material from the course you agree that all materials of the course are solely provided "as is" without any guarantee of functionality. All methods are provided for training purposes. Course developed by non security expert by explaining the practical use of **OpenSSL** software library in `R Statistical Software`. There is a risk that you can loose your information in case you are not properly follow the instructions or by loosing your private key or alike. Make sure you know what you do at any time when using the material of the course. Always test your knowledge on dummy data before applying it to real data... Memory areas for your private key, secrets, or passphrase are not securely cleaned after use. You are using the material of the course at your own risk!

#### Lecture 16 Keep Encrypted Data in Public Version Control Repository

Hello and welcome back to the course. In this lecture we will cover simple idea of keeping encrypted information in the Public Version Control Repository. This is useful when you work on common project that either require access to the remote database or you work with data that are sensitive.

In order to achieve our goal will be using package 'secret'. Main idea is to keep part of R project encrypted... to get started you will need to install package secret in R. You can use the following code for that:

```{r}
# detach, remove, install latest package
if ("package:secret" %in% search()) { detach("package:secret", unload=TRUE) }
# if ("secret" %in% rownames(installed.packages())) { remove.packages("secret") } # removes package
if (!"secret" %in% rownames(installed.packages())) { install.packages("secret") }

library(secret)
citation("secret")
```

Once you have installed this package let's have a look on our learning objectives for this lecture:

* we will get the main idea on the usage of package secret
* after that we will simulate the practical use

##### Main idea

Let's start with situation where have our local project and we want to use public version control repository to store piece dataset that needs to be encrypted. Collaborator 1 in this case have public and private keys available in the computer file system. This collaborator will then create a *vault* which will contain public key, secret and can be synchronized to the public version control repository. If necessary Colaborator 1 can use public key of collaborator 2 in order to allow her or him to use encrypted information... The encrypted information can be obviously decrypted with private keys and be available on the local systems

##### Practiacal use

Now we will review usage of this package to re-create this entire process... we will follow these steps:

* loading package 'secret'
* create vault
* add users to the vault
* add secret to the vault
* get the secret from the vault
* updating the secret in the vault
* adding users to access the secret...
* getting secret by collaborators
* adding another secret to the vault
* removing users from accessing secrets
* deleting the secrets...

##### Learn 'secret' package for your own secrets in Version Control

We will start by loading package secret

##### loading packages

```{r, message=FALSE, warning=FALSE}
# if necessary install.packages("secret") or from github devtools::install_github('secret')
library(secret)
library(tidyverse)
```

This was easy... let's now create a vault

##### vault

A vault is a folder that will contain public keys of the users and pieces of encrypted information ... we can create vault in our R project folder by executing function `create_vault()`. We will set the name of our vault to be `COMMON_SECRETS`

```{r}
# create vault
if(!dir.exists("COMMON_SECRETS")){
create_vault("COMMON_SECRETS")}
```

Feel free to open this folder... as you will notice we now have few sub-folders which at this moment are empty

##### add users

Now we will add users to that vault. At first I will be using my public key stored on USB stick

```{r, eval=FALSE, include=TRUE}
# adding user to the vault
add_user(email = "vz",
         public_key = file.path("F:/public.key"),
         vault = "COMMON_SECRETS")
```

What is happenning now is that function is now adding my 'public' key to the folder users

##### add secrets

The next step for me will be to add a secret to our vault. In this case I will use my file 'passwords.csv' which I have in my project directory. Of course this file can be anywhere on the computer. Notice that I have to specify the name of the secret, let it be passwords, I provide the information that needs to be encrypted, I specify user that will be using this information and of course the vault name.

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
# adding a secret
add_secret(name = "passwords", 
           value = read_csv("passwords.csv"),
           users = "vz",
           vault = "COMMON_SECRETS")

```

Right now we can check that secret with the name 'passwords' is already in the Vault. This vault can be obviously be 'commit' ted to the Public Repository... 

##### get secrets

Next I will demonstrate the ability to decrypt secret having the private key... all I need to do is to provide my password

```{r, eval=FALSE, include=TRUE}
# decrypting secret from Vault (password from private key is asked in interactive mode)
get_secret("passwords",
            key = file.path("F:/private.key"),
            vault = "COMMON_SECRETS")
```

and now my information was decrypted

##### update the secret

In the event of changing password I will now need to **update_secret()**. For example I will now change my file manually and add one row

```{r, message=FALSE, warning=FALSE}
# updating the secret
library(tidyverse)
read_csv("passwords.csv") %>% 
add_row(USERNAME = "kmdl",
        EMAIL = "ddasdfsdfasdfasdfafde@mail.com",
        PASSWORD = "876s-9ksd-bndk",
        DESCRIPTION = "adding one more fake password") %>% 
write_csv("passwords.csv")
# view them
read_csv("passwords.csv")
```

Now we can finally update the 'passwords' object in the vault

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
# update object 'secret' in the vault
update_secret('passwords', 
              read_csv("passwords.csv"),
              key = file.path("F:/public.key"), 
              vault = "COMMON_SECRETS")
```

this way our secret was updated directy in the vault...

##### share secret

Objective of the lecture was also to share the secret. For that I will now add another user. This user named 'sam' has provided his public key... for the sake of simplicity the public key of sam can be found in the Project Folder

```{r, eval=FALSE, include=TRUE}
# sam.public.key is stored in the R Project file
add_user("sam", public_key = "sam.public.key",
         vault = "COMMON_SECRETS")
```

If I now check my vault I will see there if file 'sam.pem' which is the public key of sam. I was also copied to the vault.

It is possible to list users that are in the vault:

```{r}
list_users(vault = "COMMON_SECRETS")
```

and the secrets that are in the vault:

```{r}
list_secrets(vault = "COMMON_SECRETS")
```

at this moment sam can't access this secret:

```{r, eval=FALSE, include=TRUE}
# if sam is not listed in the users for this secret he can't access it...
secretsam <- get_secret("passwords",
                     key = "sam.private.key",
                     vault = "COMMON_SECRETS")
```

Even if I add password of sam it's still not possible to get access to the secret. In order to finally share the secret with 'sam' we need to use **share_secret()** function:

pay attention that private key used by second user 'vz' must be indicated...

```{r, eval=FALSE, include=TRUE}
# share secret with 'sam
share_secret("passwords", users = "sam",
             file.path("F:/private.key"),
             vault = "COMMON_SECRETS")
```

Now we can see that more objects are added to the vault...

##### accessing secret by collaborator sam

Now 'sam' can det the secret:

```{r, eval=FALSE, include=TRUE}
# secret read by sam
get_secret("passwords",
           key = "sam.private.key",
           vault = "COMMON_SECRETS")
```

##### adding another secret to the vault

Now let's assume that I have a Database API key that I want to encrypt and share to both collaborators 'vz' and 'sam'... it will be necessary to use function **add_secret()**. We will indicate name of the secret, string with your password and users. Folder indicating vault will follow as the last argument for this function:

```{r, eval=FALSE, include=TRUE}
# adding api keys as a secret
add_secret(name = "api_key1",
           value = "q342sde099sdsdflfnaks972k2l",
           users = c("vz", "sam"),
           vault = "COMMON_SECRETS")
```

Once the changes are committed to the github repository it will become possible for both users to access this api key!!!

For example, one can access api key with function get secret:

```{r, eval=FALSE, include=TRUE}
# saving api key to the varialble...
get_secret('api_key1',key = "sam.private.key", vault = "COMMON_SECRETS")
```


##### stop accessing the secret to specific user

Package secret is also allowing to stop access to the vault with specific secret. We do this with unshare_secret() function

```{r, eval=FALSE, include=TRUE}
# unshare secret to bob
unshare_secret("passwords", users = "sam", vault = "COMMON_SECRETS")
```

Sam will not be able to read this secret anylonger

```{r, eval=FALSE, include=TRUE}
# trying to read secret with sam's private key
get_secret("passwords", key = "sam.private.key", vault = "COMMON_SECRETS")
```

We can also delete user entirely if we want to

```{r, eval=FALSE, include=TRUE}
# deletes the user
delete_user("sam", vault = "COMMON_SECRETS")
```


##### deleting secret that is not used anymore

To delete the secret, for example secret 'api_key1' we can intuitively use function **delete_secret()**

```{r, eval=FALSE, include=TRUE}
# delete secret
delete_secret('api_key1', vault = "COMMON_SECRETS")
```

The Entire folder with secret 'api_key1' will be deleted...

#### Conclusion

At this point we have covered the scenario of keeping shared information in the public repository. This is now possible to keep encrypted information in the vault, manage access to this informtion to several users who provided us their public keys... 

I will be waiting you in the next lecture where we will talk about how to keep your encrypted secrets in your google drive folder!!!